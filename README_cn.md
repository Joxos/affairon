# Affairon

一个面向“需求接缝”的事务（affair）驱动框架：把需求**暴露为事务接缝**，让多个回调在一个接缝上协作并进行结果合并。

---

## 定位与理念

传统扩展往往要求“写新代码 + 改原代码”。
affairon 的主张是：把需求看作是一个事务接缝，实现了事务功能的回调（callback）像**插件**一样挂载；
对接缝的调用（affair call）像调用一个**大型可扩展函数**：

- 多个回调可在同一接缝上协作
- 回调结果可进行结果合并并返回
- 事务即规约（affair-as-contract）

---

## 核心特性

- **类型安全**：事务为 Pydantic 模型
- **便于演化**：事务类支持继承
- **顺序可控**：通过 `after` 声明执行顺序，框架可以基于多种策略生成分层执行计划
- **天然并发**：由于控制了必须控制的执行顺序，接缝上的其他任务是天然并发的
- **结果聚合**：多个回调返回字典值，最终合并

---

## 设计权衡

此范式并非“万能”，但它的收益明确、成本也明确：

**收益**

- 架构更清晰：接缝即契约
- 扩展更安全：事务 类型可追踪、可重构、可验证
- 执行更可控：显式顺序/并发

**成本/风险**

- 调试需要更强的链路可视化
- 组合与扩展带来维护成本（版本、兼容、测试）
- 抽象带来性能损耗（可内聚热路径规避）

affairon 的长期目标是：通过框架辅助减少成本与风险（事务栈、冲突检测、演化策略）

---

## 重要语义

- **回调返回值**：回调返回 `dict` 会被合并；返回 `None` 视为无贡献
- **冲突处理**：字典 key 冲突将抛出 `KeyConflictError`
- **dependency order**：通过 `after` 明确“必须先执行”的回调
- **异步并发**：同一层级回调并行运行；失败时可能出现 `ExceptionGroup`

---

## 项目愿景

如果你认同这种范式，欢迎参与讨论与贡献。

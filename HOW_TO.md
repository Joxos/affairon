# HOW_TO.md — AI 驱动开发流程（AI-Driven Development Process）

> 本文档定义了从零开始、以 AI 为核心执行者的软件开发全流程。  
> 每个参与的 AI Agent 在开始工作前**必须**阅读本文档并严格遵守。

---

## 0. 术语约定

| 术语 | 定义 |
|------|------|
| **用户** | 提出需求、做最终决策的人 |
| **Agent** | 执行开发任务的 AI |
| **断言** | 用户确认的、不可再分解的事实陈述（类似公理） |
| **假设** | 关于业务逻辑与需求的未经用户确认的推断 |
| **组件** | 系统中可独立描述接口与职责的最小单元 |
| **契约** | 组件对外暴露的接口签名 + 前置条件 + 后置条件 + 不变量 |
| **第三方公理** | 第三方库在其官方文档中明确保证的行为，视同公理，无需用户确认 |

### 0.1 关于假设的禁止规则

- **业务逻辑假设**：**禁止**在任何阶段引入。所有业务逻辑必须经用户确认后作为断言记录。
- **技术实现假设的允许范围**：
  - **允许**：Python 语言语义、标准库行为（如 `dict` 的时间复杂度、`asyncio` 的事件循环模型）。
  - **允许**：第三方公理（第三方库在其官方文档中明确保证的行为）。
  - **禁止**：第三方库未在文档中明确保证的行为（如内部实现细节、未文档化的副作用）。
  - **禁止**：对性能特征的假设（如"这个操作足够快"），除非有文档化的复杂度保证。

---

## 1. 需求澄清 → `PRD.md`

**目标**：将用户的模糊意图转化为一份逻辑自洽、无孤立概念、无隐含假设的产品需求文档。

### 1.1 流程

1. 用户陈述初始想法。
2. Agent 针对以下维度**逐一**提问，直到用户确认无遗漏：
   - **用户画像**：谁使用？角色与权限？
   - **核心行为**：用户执行的关键操作是什么？
   - **数据模型**：需要持久化哪些数据？数据之间的关系？
   - **展示层**：需要向用户展示什么？在什么设备上？
   - **状态转移**：成功/失败/异常各导致什么后果？
   - **非功能需求**：性能、安全、可用性、国际化等。
   - **边界情况**：极端输入、并发、空状态、权限越界等。
3. 每轮提问后，Agent 将已确认的断言追加到 `PRD.md` 草稿。
4. 当且仅当**所有断言构成的集合逻辑自洽、无遗留假设**，且用户明确批准后，`PRD.md` 定稿。

### 1.2 提问规范

- 问题**必须**完整且具体。
- 问题**应当**为选择题，或至少给出可能的选项、参考意见和示例。
- **禁止**提出不完整的问题，例如：
  - "监听器如何处理？"（监听器是什么？监听器要处理什么？）
  - "异常情况如何处理？"（异常情况可能有哪些？有什么可能的策略？）

### 1.3 `PRD.md` 格式要求（示例）

```
# PRD — <项目名>

## 1. 概述
<一句话描述项目目标>

## 2. 用户与角色
- 角色A：<描述>
- 角色B：<描述>

## 3. 功能需求（按优先级排序）
### F-001: <功能名>
- 触发条件：...
- 输入：...
- 处理逻辑：...
- 输出/结果：...
- 异常处理：...

## 4. 非功能需求
- 性能：...
- 安全：...

## 5. 约束与假设
<此处应为空或仅包含用户明确声明的已知约束>

## 6. 术语表
```

---

## 2. 架构设计 → `INFRASTRUCTURE.md`

**目标**：将 `PRD.md` 中的需求映射为可实现的技术架构。

### 2.1 流程

1. Agent 依据 `PRD.md` 提出架构方案（组件划分、技术栈、交互方式）。
2. 用户审阅并反馈，Agent 修改，直到用户批准。
3. 输出 `INFRASTRUCTURE.md` 初稿，包含**组件图**与**依赖图**。

### 2.2 `INFRASTRUCTURE.md` 格式要求

```
# INFRASTRUCTURE — <项目名>

## 1. 系统总览
<组件关系的文字描述或 ASCII 图>

## 2. 技术栈
| 层 | 技术 | 版本 | 理由 |
|----|------|------|------|

## 3. 组件清单
### C-001: <组件名>
- 职责：...
- 依赖：[C-xxx, ...]
- 部署方式：...
```

---

## 3. 契约设计 → 追加至 `INFRASTRUCTURE.md`

**目标**：为每个组件定义精确的对外接口。

### 3.1 流程

1. 对 `INFRASTRUCTURE.md` 中的每个组件，Agent 列出其公开 API。
2. 每个 API 使用**契约式描述**：
   - **签名**：函数/方法名、参数类型、返回类型
   - **前置条件**（Pre）：调用前必须满足的条件
   - **后置条件**（Post）：调用后保证成立的条件
   - **不变量**（Inv）：调用前后始终成立的条件
   - **副作用**：对外部状态的修改
   - **错误**：可能抛出的异常及其含义
3. 用户确认后追加到 `INFRASTRUCTURE.md`。

### 3.2 契约格式（示例）

```
### C-001 API

#### `create_user(name: str, email: str) -> User`
- Pre: `name` 非空且长度 ≤ 128；`email` 符合 RFC 5322
- Post: 数据库中存在一条对应记录；返回的 `User.id` 唯一
- Inv: 用户总数单调递增
- 副作用: 写入数据库
- 错误: `DuplicateEmailError` — 邮箱已存在
```

---

## 4. 内部逻辑设计 → 追加至 `INFRASTRUCTURE.md`

**目标**：将每个组件的契约向内推导，明确内部方法与算法。

### 4.1 流程

1. 对每个公开 API，Agent 推导其实现所需的内部方法。
2. 对复杂逻辑使用**伪代码**或**状态机**描述。
3. 标注时间/空间复杂度（如适用）。
4. 用户确认后追加到 `INFRASTRUCTURE.md`。

---

## 5. 实现计划 → `PLAN.md`

**目标**：将 `INFRASTRUCTURE.md` 转化为有序的实现步骤。

### 5.1 流程

1. Agent 对组件进行**拓扑排序**（按依赖关系）。
2. 将排序结果划分为实现阶段，每阶段包含：
   - 要实现的组件/功能
   - 该阶段的验收标准（由 Agent 根据 `INFRASTRUCTURE.md` 中的契约自动推导，用户**必须**审阅）
   - 预计涉及的文件
   - 预计的 commit 节点（每个阶段至少一个 commit）
   - 标注该阶段是否涉及并发/同步逻辑，如涉及则标注需要特别注意的点
3. 如果项目需要特殊的分支策略（非默认），在 `BRANCHES.md` 中说明（见§7）。
4. 用户确认后输出 `PLAN.md`。

### 5.2 `PLAN.md` 格式要求（示例）

```
# PLAN — <项目名>

## 阶段 1: <名称>
- 目标: ...
- 组件: [C-001, C-002]
- 验收标准:
  - [ ] 测试 T-001 通过
  - [ ] 测试 T-002 通过
- 涉及文件: ...
- 预计 commit: `feat: implement event base class`
- 并发注意点: 无 / <描述>

## 阶段 2: <名称>
...
```

---

## 6. 迭代实现 + 测试

**目标**：按 `PLAN.md` 逐阶段实现代码，每阶段伴随测试。

### 6.1 流程

每个阶段的实现分为三个步骤，**步骤之间必须经用户显式批准方可进入下一步骤**：

**步骤 A — 骨架生成**：

1. 按 `INFRASTRUCTURE.md` 中的契约生成整体 API 与函数/类骨架（签名、docstring、`raise NotImplementedError`）。
2. 用户审阅骨架，确认接口设计无误后批准。

**步骤 B — 测试编写**：

1. 在骨架批准后、具体实现开始前，依据契约编写测试用例。
2. 测试**必须**符合§6.2中的测试规范。
3. 此时运行测试，预期全部失败（因为实现尚未完成）。
4. 用户审阅测试用例，确认覆盖度和质量后批准。

**步骤 C — 具体实现**：

1. 填充骨架中的具体实现逻辑。
2. 运行测试，确保全部通过。
3. 提交代码，在 `PLAN.md` 中勾选已完成项。

**阶段间过渡**：当前阶段的步骤 C 完成并通过测试后，必须经用户显式批准方可进入下一阶段。

如实现中发现 `INFRASTRUCTURE.md` 有误或不足，**先更新文档，再修改代码**。

### 6.2 测试规范

#### 6.2.1 强制规则

| 编号 | 规则 | 说明 |
|------|------|------|
| T-01 | 每个公开 API 的契约中的**前置条件、后置条件、不变量**各至少对应一条测试 | 确保契约被验证 |
| T-02 | 边界情况至少覆盖 `PRD.md` 中列出的所有场景 | 确保边界行为正确 |
| T-03 | 每条测试**必须**包含有意义的断言 | 禁止 `assert True`、空断言、仅检查"不抛异常" |
| T-04 | 测试之间**必须**相互独立，不依赖执行顺序 | 禁止隐式状态共享 |
| T-05 | 每条测试只验证一个行为 | 单一职责原则 |
| T-06 | 测试命名**必须**描述被测试的行为，而非实现细节 | 如 `test_emit_triggers_all_registered_listeners`，而非 `test_loop` |
| T-07 | 异常路径**必须**有对应测试 | 使用 `pytest.raises` 验证异常类型和消息 |
| T-08 | 异步测试**必须**使用 `pytest-asyncio` | 确保异步行为在事件循环中正确执行 |
| T-09 | 每次 commit 提交和 merge 等阶段性代码改动前**必须**运行全部测试 | 确保代码改动未引入回归 |

#### 6.2.2 推荐规则

| 编号 | 规则 | 说明 |
|------|------|------|
| T-R1 | 使用 `pytest.fixture` 管理测试数据和共享资源 | 减少重复，提高可维护性 |
| T-R2 | 对复杂场景使用 `pytest.mark.parametrize` 参数化测试 | 提高覆盖度 |
| T-R3 | mock/stub 仅用于隔离外部依赖（如网络、文件系统），不 mock 被测代码的内部方法 | 避免测试与实现耦合 |
| T-R4 | 使用 `Given-When-Then` 注释组织测试结构 | 提高可读性 |
| T-R5 | 对有状态的对象，测试其完整的生命周期 | 如创建 → 使用 → 销毁 |
| T-R6 | 将 fixtures 放在 `conftest.py` 中，测试文件按模块组织 | 保持测试目录结构清晰 |

#### 6.2.3 覆盖率要求

- 不设硬性覆盖率指标。
- Agent **必须**对未覆盖的代码路径作出书面说明，供用户审查。
- 说明格式：在 commit message 或阶段总结中列出未覆盖的路径及原因。

---

## 7. 版本控制

### 7.1 Commit 规范

- 所有 commit message **必须**使用 [Conventional Commits](https://www.conventionalcommits.org/) 格式。
- 详细规范参见项目根目录的 `CONV_COMMIT.md`。
- 格式：`<type>(<scope>): <description>`
- 常用 type：`feat`、`fix`、`test`、`docs`、`refactor`、`chore`。

### 7.2 分支策略（默认）

| 分支 | 用途 | 操作者 |
|------|------|--------|
| `dev-ai` | Agent 的工作分支，所有 Agent 的 commit 提交到此分支 | Agent |
| `dev` | 用户在此分支上 merge 审阅 `dev-ai` 的更改 | 用户 |
| `main` | 稳定分支，用户将审阅通过的更改合并到此分支 | 用户 |

- 如有特殊的分支需求，用户须在 `BRANCHES.md` 中另行说明，Agent **必须**在开始工作前检查 `BRANCHES.md` 是否存在。

---

## 8. 代码规范

### 8.1 通用规范（适用于所有项目）

| 类别 | 规范 |
|------|------|
| 命名规范 | 遵循 PEP 8（函数/变量 `snake_case`，类 `PascalCase`，常量 `UPPER_SNAKE_CASE`） |
| 代码格式化 | 使用 `ruff format` |
| 静态检查 | 使用 `ruff check` |
| import 排序 | 使用 `isort`（通过 ruff 集成，不允许独立运行） |
| type hints | 使用 PEP 585 内置泛型写法（`list[str]`、`dict[str, int]`、`tuple[int, ...]`），**禁止**使用 `typing.List`、`typing.Dict` 等旧写法。可选类型使用 `X \| None`，**禁止**使用 `typing.Optional`（减少 `typing` 模块导入，保持风格一致） |
| 枚举值 | 使用 `enum.Enum`（Python 3.11+）或者对于特定数据类型使用更新的实现（如`enum.StrEnum`），**禁止**使用字面值字符串枚举（如 `"propagate" \| "capture"`） |
| 标准库优先 | 优先使用标准库提供的数据结构和工具，**禁止**重新实现标准库已提供的功能。如有特殊需求，应继承标准库实现并扩展 |
| docstring | Google Style |
| 包管理 | 使用 `uv` |
| 测试框架 | `pytest` + `pytest-asyncio` |

### 8.2 Python 项目

- commit message 必须使用 Conventional Commits（见§7.1）。
- 所有python变量必须编写类型注解，除非有充分理由不这么做。
- 所有代码必须通过格式化和静态检查后方可提交。

---

## 9. Agent 行为规范

### 9.1 工作量控制

- Agent 在每次回复中所做的工作量**应当**控制在一个 git commit 的体量以内。
- Agent 在划分任务时应尽可能减少划分数量，尽量一次性完成。即使有疑问和需要商榷的点，也应先做草稿/空置案，在最后一并提出。

### 9.2 进度汇报

- Agent **必须**在每轮回复的末尾总结当前进度并询问下一步。

### 9.3 问题处理

- Agent 在实现过程中发现问题时，**应当**记录后继续工作，在回复末尾集中指出所有发现的问题。
- 如果问题影响实现，Agent 可以悬置该部分或只完成草稿，并在回复末尾说明原因，但无论草稿完成度如何绝不允许实现到一半时中断。

### 9.4 批判性思考

- Agent 收到用户反馈后**应当**批判性思考，只接受合理的反馈以保证代码质量。
- 如果用户的反馈与已有断言矛盾，Agent **必须**以用户反馈为准，但**必须**同时提出警告并更新相关断言。

### 9.5 提问规范

- Agent 在向用户提问时，**必须**同步给出参考意见、可选方案和/或示例。
- **禁止**提出没有参考选项的开放式问题。

### 9.6 多 Agent 协作

- Agent 之间的协作边界由 `PLAN.md` 界定。每个阶段可标注负责的 Agent 身份。
- 不同 Agent 之间通过文档（`PRD.md`、`INFRASTRUCTURE.md`、`PLAN.md`）同步状态，不依赖对话上下文。

### 9.7 技术债记录

- 对于中途作出的为了快速开发而不完全合理的技术决定，Agent **必须**将问题记录在 `TODO.md` 中。
- 每条记录包含：编号、问题描述、产生原因、建议的后续改进方向。
- Agent 在实现过程中如果选择了"先用简单方案，后续优化"的路径，**必须**在 `TODO.md` 中留下条目。

### 9.8 技术决策讨论记录

- 用户与 Agent 之间就技术方案进行的讨论，Agent **必须**将讨论过程和最终结论记录到 `TECH_DISCUZ.md` 中。
- 每条记录包含：编号、讨论主题、备选方案、最终决策及理由。
- 记录时机：在用户确认技术决策后，立即追加到 `TECH_DISCUZ.md`。

### 9.9 Commit Message 建议

- Agent 在每次阶段性任务完成后**必须**给出 commit message 建议。
- commit message **必须**遵循 Conventional Commits 格式（见§7.1 及 `CONV_COMMIT.md`）。
- 建议应反映本次阶段性任务的实际变更内容，而非笼统描述。

---

## 10. 交付与回顾 → `REVIEW.md`

**目标**：交付项目并总结经验。

### 10.1 触发时机

`REVIEW.md` 在以下两种情况下生成或更新：

1. **用户指出错误后**：Agent 修复错误，并在 `REVIEW.md` 中记录错误原因、修复方案和预防措施。
2. **项目整体验收后**：Agent 生成完整的 `REVIEW.md`，内容包括：
   - 与原始 `PRD.md` 的符合度对照
   - 实现过程中的偏差与原因
   - 遇到的技术难点与解决方案
   - 对流程本身的改进建议

---

## 附录 A：关于精确描述语言

在上述流程中，为最小化歧义、最大化简洁性，推荐以下实践：

| 场景 | 推荐方式 | 理由 |
|------|---------|------|
| 数据模型 | **JSON Schema** 或 **TypeScript 接口** | 类型精确、机器可解析 |
| API 契约 | **契约式设计**（Pre/Post/Inv） | 数学化，消除歧义 |
| 状态转移 | **状态机图**（Mermaid 语法） | 穷举所有状态与转移 |
| 实现逻辑 | **伪代码** | 语言无关、简洁 |
| 组件关系 | **依赖图**（DAG） | 可用于拓扑排序 |
| 需求条目 | **Given-When-Then**（BDD 风格） | 可直接转化为测试 |

---

## 附录 B：流程检查清单

Agent 在每个阶段结束前，对照以下清单自检：

### B.1 通用检查项

- [ ] 本阶段产出文档中是否存在未确认的假设？
- [ ] 所有新引入的术语是否已在术语表中定义？
- [ ] 所有组件是否都有明确的职责边界？
- [ ] 所有 API 是否都有完整的契约描述？
- [ ] 是否存在孤立的概念（被引用但未定义，或已定义但未被引用）？
- [ ] 文档变更是否已同步到所有相关文档？

### B.2 PRD 编写专项清单（在§1.1第4步后执行）

在 PRD 定稿前，**必须**逐项检查以下维度：

#### B.2.1 时序与时机的完整性

- [ ] 每个数据生成/修改操作都有明确的**时机**（初始化时？提交时？注册时？）
- [ ] 每个状态变更都有明确的触发条件
- [ ] 同步/异步上下文切换点已明确标注

#### B.2.2 数值语义的一致性

- [ ] 所有数值型配置（如 priority）的语义已确认（越大越好还是越小越好？）
- [ ] 边界值已定义（0、-1、None 的含义）

#### B.2.3 错误处理的完备性

- [ ] 每种错误场景都有明确的处理策略
- [ ] 配置 API 已定义（如果用户可配置错误处理策略）
- [ ] 异常类型已列出

#### B.2.4 一致性与约束验证

- [ ] 与之前所有决策进行一致性检查（如：是否违反了"同步只能有同步监听器"的约定？）
- [ ] 跨功能一致性检查（如：同步和异步的行为是否一致？）

#### B.2.5 输入输出的精确性

- [ ] 每个函数的输入参数类型和数量已精确
- [ ] 每个函数的返回值类型和结构已精确
- [ ] 多态输入（如：支持单值或列表）已明确标注
- [ ] 返回值合并/聚合策略已定义（如果有多个返回值）
- [ ] 键冲突、值冲突等合并冲突的处理策略已定义

#### B.2.6 架构理解的准确性

- [ ] 执行模型已明确（单线程？多线程？协程？）
- [ ] 阻塞/非阻塞行为已明确
- [ ] 队列的真实用途已理解（控制递归？解耦生产消费？线程通信？）
- [ ] "消费者"概念是否适用当前架构（单线程模型中可能不存在消费者线程）

#### B.2.7 边界情况的穷尽

- [ ] 空状态（无监听器、空队列等）已处理
- [ ] 极端输入（最大队列长度、循环依赖等）已处理
- [ ] 并发/竞态条件已考虑

#### B.2.8 生命周期管理

- [ ] 启动流程已定义
- [ ] 停机/清理流程已定义（同步和异步是否都支持？）
- [ ] 资源释放策略已定义

### B.3 测试质量检查（在§6.1步骤 B 后执行）

- [ ] 测试是否覆盖了正常路径和异常路径？
- [ ] 每条测试是否包含有意义的断言（非 `assert True`）？
- [ ] 测试之间是否相互独立（无隐式状态依赖）？
- [ ] 测试命名是否描述了被测试的行为？
- [ ] mock/stub 是否仅用于隔离外部依赖？
- [ ] 未覆盖的代码路径是否已书面说明原因？

### B.4 常见错误模式（自查表）

| 错误类型 | 检查问题 | 示例 |
|----------|----------|------|
| **遗漏时机** | "什么时候生成/发生？" | event_id 在初始化时还是提交时生成？ |
| **数值歧义** | "这个数值越大越好还是越小越好？" | priority=1 和 priority=100 哪个优先？ |
| **指代不清** | "这里的 X 具体指什么？" | "监听器不存在"是指函数不存在还是未注册？ |
| **API 不一致** | "这两个相似功能的 API 是否对称？" | 装饰器支持列表，方法调用是否也支持？ |
| **上下文遗漏** | "是否需要检查运行环境？" | 异步函数是否在事件循环内调用？ |
| **配置缺失** | "如何配置这个行为？" | 错误处理策略如何设置？ |
| **决策矛盾** | "这与之前的决策是否冲突？" | 之前说同步只能有同步监听器，现在是否违反？ |
| **场景遗漏** | "同步版本是否也需要这个功能？" | 优雅停机是否只实现了异步版本？ |
| **架构误解** | "执行模型是什么？有消费者线程吗？" | 同步模式是单线程还是多线程消费者？ |
| **防御过度** | "这个检查是否已在更早阶段完成？" | emit 是否需要检查已在注册时保证的条件？ |
| **合并冲突** | "多个返回值如何合并？冲突怎么办？" | 键冲突是覆盖还是报错？ |

---

## 附录 C：原始流程的不足分析与本文档的改进

### 精确描述语言的选择

自然语言存在固有歧义。本文档通过以下方式缓解：

- 对**接口**使用契约式设计（类似于 Eiffel 语言的 Design by Contract）
- 对**数据**使用 JSON Schema 或类型注解
- 对**行为**使用 Given-When-Then 或状态机
- 对**结构**使用依赖图

完全消除歧义需要形式化方法（如 TLA+、Alloy），但其学习成本与收益比在大多数项目中不合理。上述折中方案在可读性与精确性之间取得平衡。

### 案例研究：PRD 编写中的常见错误（Eventd 项目）

在 Eventd 项目的 PRD 编写过程中，Agent 犯了以下典型错误：

#### 错误1：遗漏时机说明

**错误描述**：未明确 `event_id` 和 `timestamp` 的生成时机（初始化时 vs 提交时）。
**根本原因**：编写功能点时只关注了"有什么"，没关注"什么时候"。
**预防措施**：对每个数据操作，强制提问"这个操作在什么时机发生？"

#### 错误2：数值语义假设

**错误描述**：假设 `priority` 越小优先级越高，但用户期望越大越高。
**根本原因**：没有与用户确认数值语义，使用了常见但不适用于此项目的约定。
**预防措施**：对所有数值型配置，必须明确询问"数值越大越好还是越小越好？"

#### 错误3：指代歧义

**错误描述**："监听器不存在"未明确是指"函数未定义"还是"未注册"。
**根本原因**：使用模糊的自然语言描述，未意识到两种解释的可能性。
**预防措施**：对每个条件判断，强制澄清具体指代对象的状态。

#### 错误4：API 不对称

**错误描述**：装饰器方式支持多事件（`@on([E1, E2])`），但方法调用方式未体现此能力。
**根本原因**：复制粘贴功能描述时未仔细检查 API 对称性。
**预防措施**：当存在多种方式（装饰器 vs 方法调用）实现同一功能时，必须逐项对比参数。

#### 错误5：上下文检查遗漏

**错误描述**：未提及异步 emit 需要检查是否在 asyncio 事件循环内。
**根本原因**：只关注正常流程，遗漏了环境检查。
**预防措施**：对每个涉及同步/异步切换的功能，必须列出上下文检查点。

#### 错误6：配置方式缺失

**错误描述**：提及"根据配置决定"但未说明如何配置。
**根本原因**：将配置视为"实现细节"，但这是 PRD 必须明确的。
**预防措施**：每当提到"可配置"时，必须立即定义配置 API。

#### 错误7：决策矛盾

**错误描述**：F-004 中允许同步管理器调用异步监听器，违反了"同步只能有同步监听器"的决策。
**根本原因**：编写时未回顾之前的决策约束。
**预防措施**：编写每个功能前，回顾所有已确认的设计决策。

#### 错误8：场景遗漏

**错误描述**：只实现了异步模式的优雅停机，遗漏了同步模式。
**根本原因**：将"异步特有"功能错误推广，未考虑同步场景的同等需求。
**预防措施**：对每个功能，强制询问"同步版本是否也需要这个功能？"

#### 错误9：行为不一致

**错误描述**：同步队列满时抛出异常，异步队列满时阻塞，行为不一致。
**根本原因**：未考虑跨模式行为一致性。
**预防措施**：当存在同步/异步两种模式时，必须列出行为对比表。

#### 错误10：架构误解

**错误描述**：将同步单线程模型误解为多线程消费者模型，描述中存在"消费者线程"、"阻塞等待"等不适用于单线程模型的概念。
**根本原因**：未准确理解执行模型（单线程 vs 多线程），使用了自己熟悉的队列模式（生产者-消费者）而非项目实际需要的模式（递归深度控制）。
**预防措施**：明确提问：执行模型是什么？是否存在消费者线程？队列的真实用途是什么？

#### 错误11：防御过度

**错误描述**：在 emit 时检查"是否在 asyncio 事件循环中"，但注册时已经保证同步管理器只能注册同步监听器，emit 时无需重复检查。
**根本原因**：未意识到前置条件已在更早阶段（注册时）保证，添加了不必要的运行时检查。
**预防措施**：检查每个条件：这个检查是否已在注册/初始化阶段完成？是否存在冗余检查？

#### 错误12：合并冲突未定义

**错误描述**：未定义多个监听器返回值合并时的键冲突处理策略（覆盖 vs 报错）。
**根本原因**：假设用户会避免冲突，或认为框架应该静默处理，未将冲突处理策略明确化。
**预防措施**：对任何聚合/合并操作，必须定义冲突处理策略（覆盖、报错、还是忽略？）。

### 教训总结

这些错误的共同根源是：

1. **过度依赖直觉**：使用"通常"或"默认"的假设，而非与用户确认
2. **缺乏系统性检查**：没有逐项验证每个功能点的完整性
3. **忽视边界情况**：只关注正常流程，遗漏错误处理和极端场景
4. **一致性检查缺失**：未与之前的决策和跨功能进行对比
5. **架构理解不深**：使用自己熟悉的模式套用，而非理解项目实际架构
6. **防御性编程过度**：添加不必要的检查，未考虑前置条件已在更早阶段保证

**核心原则**：宁可文档冗长，不可遗漏细节。每个模糊点都是未来的 bug。

**补充原则**：

- **先理解架构，再描述功能**：确保准确理解执行模型、线程模型、数据流，避免套用熟悉但不匹配的模式
- **检查前置条件**：在添加任何检查或处理逻辑前，确认它是否已在注册/初始化阶段完成
- **显式定义冲突策略**：任何合并、聚合操作必须显式定义冲突处理策略
